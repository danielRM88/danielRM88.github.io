---
title: "Administrative System with REST API using Rails and React.js + Redux for the frontend"
date: 2018-01-12
tags: [ruby, ruby on rails, react.js, redux, jwt, web application, postgresql, database triggers, service oriented architecture]
excerpt: "Administrative system for a textile company using a web oriented architecture with Ruby on Rails for the backend API and React.js with Redux for the frontend."
---

## Table of Contents
- [Introduction](#introduction)
- [Backend](#backend)
    - [Data model](#data-model)
    - [Database](#database)
    - [Web API](#web-api)
        - [Authentication](#authentication)
- [Frontend](#frontend)


## Introduction
Multilayer service oriented architecture solution developed as an administrative system for a textile company, in order to provide a way to manage and keep track of their inventory and sales.

The project is composed of a backend application built with **Ruby on Rails** with a **PostgreSQL** database, and a frontend application developed in **Reactjs**.

## Backend
The backend of the application consists of a Web API with a Datastore. As mentioned before the API is built using Rails and the datastore selected is PostgreSQL.

For this project, the business logic will be placed in the relational database in the form of triggers. These triggers will have the responsability of maintaining a consistent inventory of fabrics. Although I am not a big advocate of having the business logic in the RDMS, it was a good learning exercise.

### Data model
Figure 1 shows the entity relationship diagram created for the application.

<figure>
  <img src="/images/data-model.png">
  <figcaption>Figure 1: data model of the application</figcaption>
</figure>

### Database
As mentioned before the database selected is PostgreSQL and the business logic of the application will be placed in it. 

To achieve this, several triggers are developed whose purpose can be seen in Figure 1 in the form of notes added to their respective table.

A total of 6 triggers are created:

1. **After insert on inventories table**. When a new fabric arrives and it is placed in the inventory, the existences table, which is the one that holds how much stock there is available at the moment, needs to be updated.

    ```
    CREATE OR REPLACE FUNCTION update_on_inventory_insert() RETURNS TRIGGER AS 
    $BODY$
        BEGIN
            --
            -- After an insert in inventories table, the sentence is replicated in existences table.
            --
            IF (TG_OP = 'INSERT') THEN
                INSERT INTO existences (inventory_id, pieces, amount, unit, created_at, updated_at)
                VALUES (NEW.id, NEW.pieces, NEW.amount, NEW.unit, current_timestamp, current_timestamp);
            END IF;
            RETURN NULL; -- result is ignored since this is an AFTER trigger
        END;
    $BODY$ LANGUAGE plpgsql;
    CREATE TRIGGER update_on_inventory_insert AFTER INSERT ON inventories FOR EACH ROW EXECUTE PROCEDURE update_on_inventory_insert();
    ```

2. **After update on purchases table**. When a purchase is modified, the existences related to that purchase need to be modified as well. The trigger must check that there is consistency between the inventories table and the existences table. We cannot have existences that come from nowhere!

    ```
    CREATE OR REPLACE FUNCTION update_on_purchase_update() RETURNS TRIGGER AS 
    $BODY$
        DECLARE
            r                inventories%rowtype;
            pexistence       integer;
            aexistence       numeric(10,2);
            pinventory       integer;
            ainventory       numeric(10,2);
        BEGIN
            --
            -- After modifying a purchase, existences table is updated
            --
            IF (NEW.purchase_state = 'CURRENT') THEN
              FOR r IN (SELECT * FROM inventories i WHERE i.purchase_id = NEW.id) LOOP
                 INSERT INTO existences (inventory_id, pieces, amount, unit, created_at, updated_at) VALUES (r.id, r.pieces, r.amount, r.unit, current_timestamp, current_timestamp);
              END LOOP;
            ELSIF (NEW.purchase_state = 'CANCEL') THEN
              pexistence = (SELECT SUM(e.pieces) FROM existences e 
                                        INNER JOIN inventories i ON e.inventory_id = i.id
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = NEW.id));
              aexistence = (SELECT SUM(e.amount) FROM existences e 
                                        INNER JOIN inventories i ON e.inventory_id = i.id
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = NEW.id));

              pinventory = (SELECT SUM(i.pieces) FROM inventories i
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = NEW.id));
              ainventory = (SELECT SUM(i.amount) FROM inventories i
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = NEW.id));

              IF (pinventory > pexistence OR ainventory > aexistence) THEN
                RAISE EXCEPTION 'not enough in existence to cancel purchase (If fabrics have been sold cancel the INVOICES first OR check that the purchase has not already been cancelled)';
              END IF;
              FOR r IN (SELECT * FROM inventories i WHERE i.purchase_id = NEW.id) LOOP
                 DELETE FROM existences e WHERE e.inventory_id = r.id;
              END LOOP;
            END IF;
        
            RETURN OLD;
        END;
    $BODY$ 
    LANGUAGE plpgsql;
    CREATE TRIGGER update_on_purchase_update AFTER UPDATE ON purchases FOR EACH ROW EXECUTE PROCEDURE update_on_purchase_update();
    ```

3. **Before delete on purchases table**. When a purchase is deleted, the inventories and existences associated with it must be removed from the system as well. The trigger also checks that there is enough in existences to satisfy the amount of fabrics that were aqcuired in the purchase.

    ```
    CREATE OR REPLACE FUNCTION update_on_purchase_delete() RETURNS TRIGGER AS 
    $BODY$
        DECLARE
            r                inventories%rowtype;
            sales            integer;
            pexistence       integer;
            aexistence       numeric(10,2);
            pinventory       integer;
            ainventory       numeric(10,2);
        BEGIN
            sales = (SELECT COUNT(*) FROM sales si
                                     INNER JOIN inventories i ON si.inventory_id = i.id
                                     INNER JOIN purchases p ON p.id = i.purchase_id
                                     WHERE p.id = OLD.id);
            
            IF (sales > 0) THEN
                RAISE EXCEPTION 'fabrics have been sold (delete invoices first)';
            END IF;

            IF (OLD.purchase_state = 'CURRENT') THEN
              pexistence = (SELECT SUM(e.pieces) FROM existences e 
                                        INNER JOIN inventories i ON e.inventory_id = i.id
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = OLD.id));
              aexistence = (SELECT SUM(e.amount) FROM existences e 
                                        INNER JOIN inventories i ON e.inventory_id = i.id
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = OLD.id));

              pinventory = (SELECT SUM(i.pieces) FROM inventories i
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = OLD.id));
              ainventory = (SELECT SUM(i.amount) FROM inventories i
                                        INNER JOIN purchases pu ON pu.id = i.purchase_id
                                        WHERE (pu.id = OLD.id));

              IF (pinventory > pexistence OR ainventory > aexistence) THEN
                RAISE EXCEPTION 'not enough in existence to delete purchase (there may be some data inconsistency)';
              END IF;
            END IF;

            FOR r IN (SELECT * FROM inventories i WHERE i.purchase_id = OLD.id) LOOP
               DELETE FROM existences e WHERE e.inventory_id = r.id;
            END LOOP;

            DELETE FROM inventories i WHERE i.purchase_id = OLD.id;
        
            RETURN OLD;
        END;
    $BODY$ 
    LANGUAGE plpgsql;
    CREATE TRIGGER update_on_purchase_delete BEFORE DELETE ON purchases FOR EACH ROW EXECUTE PROCEDURE update_on_purchase_delete();
    ```

4. **After insert on sales table**. When an invoice is created, the sales table is populated with all the fabrics sold. The trigger checks that these fabrics actually exist in the existences table otherwise there will be inconsistency in the database.

    ```
    CREATE OR REPLACE FUNCTION update_on_invoice_insert()
      RETURNS trigger AS
    $BODY$
        DECLARE
            p       integer;
            a       numeric(10,2);
        BEGIN
            --
            -- After an insert in invoices and sales table, the quantities and pieces in existences are reduces.
            --
            p = (SELECT e.pieces FROM existences e WHERE e.inventory_id = NEW.inventory_id);
            a = (SELECT e.amount FROM existences e WHERE e.inventory_id = NEW.inventory_id);
            IF (TG_OP = 'INSERT') THEN
                IF (a - NEW.amount) < 0 THEN RAISE EXCEPTION 'not enough amount in existence'; END IF;
                IF (p - NEW.pieces) < 0 THEN RAISE EXCEPTION 'not enough pieces in existence'; END IF;
                IF (((a - NEW.amount) = 0 AND (p - NEW.pieces) != 0) OR ((a - NEW.amount) != 0 AND (p - NEW.pieces) = 0)) THEN 
                  RAISE EXCEPTION 'inconsistency between pieces and amount (one is zero the other is not)'; 
                END IF;
                UPDATE existences SET 
                  amount = (a - NEW.amount),
                  pieces = (p - NEW.pieces)
                WHERE inventory_id = NEW.inventory_id;
                DELETE FROM existences WHERE amount = 0 AND pieces = 0;
            END IF;
            RETURN NULL; -- result is ignored since this is an AFTER trigger
        END;
    $BODY$
      LANGUAGE plpgsql;
    CREATE TRIGGER update_on_invoice_insert AFTER INSERT ON sales FOR EACH ROW EXECUTE PROCEDURE update_on_invoice_insert();
    ```

5. **After update on invoices table**. When an invoice is updated, the existences table needs to be updated accordingly. The trigger makes sure that there is no inconsistency in the existences table.

    ```
    CREATE OR REPLACE FUNCTION update_on_invoice_update()
      RETURNS trigger AS
    $BODY$
        DECLARE
            r       sales%rowtype;
            p       integer;
            a       numeric(10,2);
        BEGIN
          IF (NEW.invoice_state = 'CANCEL') THEN
            FOR r IN (SELECT * FROM sales s WHERE s.invoice_id = NEW.id) LOOP
              a = (SELECT e.amount FROM existences e WHERE e.inventory_id = r.inventory_id);
              p = (SELECT e.pieces FROM existences e WHERE e.inventory_id = r.inventory_id);
                IF (a > 0) THEN 
                    UPDATE existences SET 
                        amount = (a + r.amount),
                        pieces = (p + r.pieces)
                    WHERE inventory_id = r.inventory_id;
                ELSE
                    INSERT INTO existences (inventory_id, pieces, amount, unit, created_at, updated_at) VALUES (r.inventory_id, r.pieces, r.amount, r.unit, current_timestamp, current_timestamp);
                END IF;
            END LOOP;
          ELSIF (NEW.invoice_state = 'CURRENT') THEN
            FOR r IN (SELECT * FROM sales s WHERE s.invoice_id = NEW.id) LOOP
              p = (SELECT e.pieces FROM existences e WHERE e.inventory_id = r.inventory_id);
              a = (SELECT e.amount FROM existences e WHERE e.inventory_id = r.inventory_id);
              IF (a IS NULL OR (a - r.amount) < 0) THEN RAISE EXCEPTION 'not enough amount in existence'; END IF;
              IF (p IS NULL OR (p - r.pieces) < 0) THEN RAISE EXCEPTION 'not enough pieces in existence'; END IF;
              IF (((a - r.amount) = 0 AND (p - r.pieces) != 0) OR ((a - r.amount) != 0 AND (p - r.pieces) = 0)) THEN 
                RAISE EXCEPTION 'inconsistency between pieces and amount (one is zero the other is not)';
              END IF;
              UPDATE existences SET 
                amount = (a - r.amount),
                pieces = (p - r.pieces)
              WHERE inventory_id = r.inventory_id;
              DELETE FROM existences WHERE amount = 0 AND pieces = 0;
            END LOOP;
          END IF;
          RETURN NULL;
        END;
    $BODY$
      LANGUAGE plpgsql;
    CREATE TRIGGER update_on_invoice_update AFTER UPDATE ON invoices FOR EACH ROW EXECUTE PROCEDURE update_on_invoice_update();
    ```

6. **Before delete on invoices table**. When an invoice is deleted, the sales table and the existences table need to be updated. Sales records that belong to the invoice are deleted and the quantities are added to existences table.

    ```
    CREATE OR REPLACE FUNCTION update_on_invoice_delete()
      RETURNS trigger AS
    $BODY$
        DECLARE
            r       sales%rowtype;
            p       integer;
            a       numeric(10,2);
        BEGIN

          FOR r IN (SELECT * FROM sales s WHERE s.invoice_id = OLD.id) LOOP
            a = (SELECT e.amount FROM existences e WHERE e.inventory_id = r.inventory_id);
            p = (SELECT e.pieces FROM existences e WHERE e.inventory_id = r.inventory_id);
            IF (a > 0) THEN 
                UPDATE existences SET 
                    amount = (a + r.amount),
                    pieces = (p + r.pieces)
                WHERE inventory_id = r.inventory_id;
            ELSE
                INSERT INTO existences (inventory_id, pieces, amount, unit, created_at, updated_at) VALUES (r.inventory_id, r.pieces, r.amount, r.unit, current_timestamp, current_timestamp);
            END IF;
          END LOOP;

          DELETE FROM sales si WHERE si.invoice_id = OLD.id;

          RETURN OLD;
        END;
    $BODY$
      LANGUAGE plpgsql;
    CREATE TRIGGER update_on_invoice_delete BEFORE DELETE ON invoices FOR EACH ROW EXECUTE PROCEDURE update_on_invoice_delete();
    ```

### Web API


#### Authentication




